package syncbench

import (
	"sync"
	"sync/atomic"
	"testing"
)

type valueGeneratorFn[T any] func() T

// SyncPublish is an interface for synchronous publishing, where a collection of goroutines
// wait for
// TODO: should be generic; for now just return a string
type syncPublish[T any] interface {
	// waitForValue blocks until the value has been generated by the first caller.
	waitForValue() T
}

type mutexSyncPublisher[T any] struct {
	mu        sync.Mutex
	generated bool
	value     T
	generator valueGeneratorFn[T]
}

func newMutexSyncPublisher[T any](generator valueGeneratorFn[T]) syncPublish[T] {
	return &mutexSyncPublisher[T]{generator: generator}
}

func (m *mutexSyncPublisher[T]) waitForValue() T {
	m.mu.Lock()
	defer m.mu.Unlock()

	if m.generated {
		return m.value
	}

	m.value = m.generator()
	m.generated = true
	return m.value
}

type channelSyncPublisher[T any] struct {
	done      chan struct{}
	value     T
	generator valueGeneratorFn[T]
}

func newChannelSyncPublisher[T any](generator valueGeneratorFn[T]) syncPublish[T] {
	// create a buffered channel with a single value in it: that is the task to generate
	done := make(chan struct{}, 1)
	done <- struct{}{}
	return &channelSyncPublisher[T]{done: done, generator: generator}
}

func (c *channelSyncPublisher[T]) waitForValue() T {
	_, readValue := <-c.done
	if readValue {
		c.value = c.generator()
		close(c.done)
	}

	return c.value
}

type mutexSyncPublisherEagerInit[T any] struct {
	mu    sync.Mutex
	value T
}

func newMutexSyncPublisherEagerInit[T any](generator valueGeneratorFn[T]) syncPublish[T] {
	p := &mutexSyncPublisherEagerInit[T]{}
	p.mu.Lock()
	go func() {
		p.value = generator()
		p.mu.Unlock()
	}()
	return p
}

func (m *mutexSyncPublisherEagerInit[T]) waitForValue() T {
	m.mu.Lock()
	defer m.mu.Unlock()
	return m.value
}

type channelSyncPublisherEagerInit[T any] struct {
	done  chan struct{}
	value T
}

func newChannelSyncPublisherEagerInit[T any](generator valueGeneratorFn[T]) syncPublish[T] {
	done := make(chan struct{})
	p := &channelSyncPublisherEagerInit[T]{done: done}
	go func() {
		p.value = generator()
		close(done)
	}()

	return p
}

func (c *channelSyncPublisherEagerInit[T]) waitForValue() T {
	<-c.done
	return c.value
}

var implementations = []struct {
	name  string
	newFn func(generator valueGeneratorFn[string]) syncPublish[string]
}{
	{"mutex", newMutexSyncPublisher[string]},
	{"channel", newChannelSyncPublisher[string]},
	{"mutex_eager", newMutexSyncPublisherEagerInit[string]},
	{"channel_eager", newChannelSyncPublisherEagerInit[string]},
}

const generatedValue = "foo"

func fooGenerator() string {
	return generatedValue
}

func TestUsed(t *testing.T) {
	// ensures staticcheck knows these fields are used. Works around a bug:
	// https://github.com/dominikh/go-tools/issues/1250
	p := newMutexSyncPublisher(fooGenerator).(*mutexSyncPublisher[string])
	t.Log(p.waitForValue())
	p2 := newChannelSyncPublisher(fooGenerator).(*channelSyncPublisher[string])
	t.Log(p2.waitForValue())

	p3 := newMutexSyncPublisherEagerInit(fooGenerator).(*mutexSyncPublisherEagerInit[string])
	t.Log(p3.waitForValue())
	p4 := newChannelSyncPublisherEagerInit(fooGenerator).(*channelSyncPublisherEagerInit[string])
	t.Log(p4.waitForValue())
}

func TestSyncPublish(t *testing.T) {
	for _, impl := range implementations {
		t.Run(impl.name, func(t *testing.T) {
			const numGoroutines = 10
			const expectedValue = "foo"

			unblockPublisher := make(chan struct{})
			generatedCount := &atomic.Int32{}
			generator := func() string {
				<-unblockPublisher
				generatedCount.Add(1)
				return expectedValue
			}

			// create the object and have 10 threads all get the value
			publisher := impl.newFn(generator)
			values := make(chan string, numGoroutines)
			for i := 0; i < numGoroutines; i++ {
				go func() {
					values <- publisher.waitForValue()
				}()
			}
			close(unblockPublisher)

			for i := 0; i < numGoroutines; i++ {
				v := <-values
				if v != expectedValue {
					t.Errorf("v=%#v expected %#v", v, expectedValue)
				}
			}

			if generatedCount.Load() != 1 {
				t.Errorf("expected 1 call to generator was %d", generatedCount.Load())
			}
		})
	}

}

func BenchmarkNewAndWait(b *testing.B) {
	doNotOptimize := 0
	for _, impl := range implementations {
		b.Run(impl.name, func(b *testing.B) {
			b.ReportAllocs()
			for i := 0; i < b.N; i++ {
				publisher := impl.newFn(fooGenerator)
				v := publisher.waitForValue()
				doNotOptimize += len(v)
			}
		})
	}
	b.Logf("doNotOptimize=%d", doNotOptimize)
}

func BenchmarkWaitForValueOnly(b *testing.B) {
	doNotOptimize := 0
	for _, impl := range implementations {
		publisher := impl.newFn(fooGenerator)
		publisher.waitForValue()

		b.Run(impl.name, func(b *testing.B) {
			b.ReportAllocs()
			for i := 0; i < b.N; i++ {
				v := publisher.waitForValue()
				doNotOptimize += len(v)
			}
		})
	}
	b.Logf("doNotOptimize=%d", doNotOptimize)
}
